(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{480:function(t,s,a){"use strict";a.r(s);var e=a(4),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"强制缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[t._v("#")]),t._v(" 强制缓存")]),t._v(" "),a("p",[t._v("在 HTTP1.0 时期，使用的是 "),a("strong",[t._v("Expires")]),t._v(" 字段，会位于服务端返回的响应头 (response header) 中，记录下过期时间。等到过期时间到了，就会重新向服务器发起请求。"),a("br"),t._v("\nExpires 存在问题，就是浏览器与服务器的时间可能并不一致")]),t._v(" "),a("p",[t._v("进入 HTTP1.1 时期，开始使用 "),a("strong",[t._v("Cache-Control")]),t._v(" 字段，它可能存在的值包括："),a("br"),t._v("\nmax-age: 为缓存资源设置最大过期时间，例如下面这段，代表资源返回后6000秒内都可以继续使用缓存")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Cache-Control: max-age=6000\n")])])]),a("p",[t._v("no-cache: 不使用客户端缓存，下次继续照常请求"),a("br"),t._v("\nno-store: 不适用客户端缓存，并且也不使用服务端缓存")]),t._v(" "),a("p",[t._v("如果没有命中强制缓存，就会进入协商缓存")]),t._v(" "),a("h2",{attrs:{id:"协商缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),a("p",[t._v("在强制缓存过期失效后，浏览器将在请求头 (request header) 中带上响应的资源标识，由服务端通过判断它以决定是否返回新的资源。资源标识有两种类型字段，"),a("strong",[t._v("Last-Modified")]),t._v(" 与 "),a("strong",[t._v("ETag")])]),t._v(" "),a("p",[t._v("在初次请求中，资源标识会由服务端与资源一并返回，标识存在于响应头中。浏览器获取了资源标识，记录，并在下次请求时发起，以供服务器判断是否缓存。"),a("br"),t._v(" "),a("strong",[t._v("Last-Modified")]),t._v(" 代表的是最后修改时间，再次请求时，请求头中的字段名为 "),a("strong",[t._v("If-Modified-Since")]),t._v("。服务器将检查是否有新的修改时间，如果没有修改，返回 304，反之重新获取并更新标识。"),a("br"),t._v(" "),a("strong",[t._v("ETag")]),t._v(" 代表一个特别的值，再次请求时，请求头中的字段名为 "),a("strong",[t._v("If-None-Match")]),t._v("。服务器将其与线上资源的 "),a("strong",[t._v("ETag")]),t._v(" 对比，相同时，返回 304，反之重新获取并更新。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[t._v("当两种方式同时使用时，服务器会优先考虑 ETag")])])])}),[],!1,null,null,null);s.default=r.exports}}]);